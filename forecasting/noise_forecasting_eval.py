# -*- coding: utf-8 -*-
"""snms_noise_forecasting_eval

Automatically generated by Colaboratory.

"""

!pip install prophet

!pip install influxdb_client

import pytz
import os
from datetime import datetime
desired_timezone = pytz.timezone('Etc/GMT-2')
os.environ['TZ'] = 'Etc/GMT-2'
datetime.now(desired_timezone)

import pandas as pd
from prophet import Prophet
import datetime
import time
import seaborn as sns
import matplotlib.pyplot as plt

from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import SYNCHRONOUS
from statsmodels.tsa.statespace.mlemodel import PredictionResults
from scipy.sparse import data
from sklearn.metrics import mean_squared_error
from math import sqrt

# InfluxDB setup
token = ""
org = ""
url = ""
client = InfluxDBClient(url=url, token=token, org=org)
write_api = client.write_api(write_options=SYNCHRONOUS)

# Noise data query
query = 'from(bucket:"snms_agg")' \
        ' |> range(start:-2h)'\
        ' |> filter(fn: (r) => r._measurement == "sample")' \
        ' |> filter(fn: (r) => r._field == "noise")'

result = client.query_api().query(org=org, query=query)
print(result)

# Extracting data from FluxTable
raw_data = []
for table in result:
    for record in table.records:
        raw_data.append((record.get_value(), record.get_time()+datetime.timedelta(hours=2)))

df = pd.DataFrame(raw_data, columns=['y', 'ds'])

#Â Removing timezone
for col in df.select_dtypes(['datetimetz']).columns:
  df[col] = df[col].dt.tz_convert(None)

df = df[0:600]
size = int(len(df) * 0.7)
train, test = df[0:size], df[size:len(df)]
history = train

pred = []

# Iterate through each time step in the test data
for t in range(len(test)):
  history.head()
  model = Prophet()
  model.fit(history)
  future = model.make_future_dataframe(periods=1, freq='10s')
  forecast = model.predict(future)
  forecast[['ds', 'yhat']].tail()
  forecast['measurement'] = "forecast"
  cp = forecast[['ds', 'yhat']].copy()
  new_value_forecasted = cp.tail(1)
  # Append the forecasted value to the predictions list
  pred.append(new_value_forecasted)
  history = pd.concat([history, test[t:t+1]])



# Concatenate all the forecasted values into a dataframe
df_forecast = pd.concat(pred)
# Extract the forecasted values and timestamps
pred_values = df_forecast['yhat'].values.tolist()
pred_series = pd.Series(pred_values, df_forecast['ds'])
# Extract the original dataset's values and timestamps
dataset_values = df['y'].values.tolist()
dataset = pd.Series(dataset_values, df['ds'])

# Calculate the root mean squared error (RMSE)
test_values = test['y'].values.tolist()
mse = mean_squared_error(test_values, pred_values)
rmse = sqrt(mse)
print('MSE: %.3f' % mse)
print('RMSE: %.3f' % rmse)

# Plot forecasted and real
title = ("Prophet model with MSE: %3.f" % mse)
plt.figure(figsize=(10, 6))
plt.title(title, fontsize=12)  # Add the title here


plt.plot(dataset, label="Original Dataset Noise", linewidth=0.5)
plt.plot(pred_series, label="Forecasted Noise")
plt.legend(loc="upper left")

plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.xlabel("Timestamp", fontsize=12)
plt.ylabel("Noise", fontsize=12)
plt.show()
